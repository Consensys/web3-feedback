"use strict";(self.webpackChunkweb3_feedback=self.webpackChunkweb3_feedback||[]).push([[8166],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var a=n(96540);const s={},o=a.createContext(s);function r(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(o.Provider,{value:t},e.children)}},88645:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"technology/state-manager","title":"EVM state manager","description":"How state management works on Linea","source":"@site/docs/technology/state-manager.mdx","sourceDirName":"technology","slug":"/technology/state-manager","permalink":"/web3-feedback/technology/state-manager","draft":false,"unlisted":false,"editUrl":"https://github.com/Consensys/doc.linea/tree/main/docs/technology/state-manager.mdx","tags":[],"version":"current","lastUpdatedBy":"oliver renwick","lastUpdatedAt":1742484500000,"sidebarPosition":4,"frontMatter":{"title":"EVM state manager","description":"How state management works on Linea","sidebar_position":4,"image":"/img/socialCards/evm-state-manager.jpg"},"sidebar":"technologySidebar","previous":{"title":"Traces generation","permalink":"/web3-feedback/technology/sequencer/traces-generator"},"next":{"title":"Trace Expansion and Proving","permalink":"/web3-feedback/technology/prover/"}}');var s=n(74848),o=n(28453);const r={title:"EVM state manager",description:"How state management works on Linea",sidebar_position:4,image:"/img/socialCards/evm-state-manager.jpg"},i=void 0,c={},h=[{value:"Merkle trees",id:"merkle-trees",level:2},{value:"Sparse Merkle trees",id:"sparse-merkle-trees",level:3},{value:"Cryptographic accumulator",id:"cryptographic-accumulator",level:2},{value:"Tracking empty leaves",id:"tracking-empty-leaves",level:3},{value:"Applying the accumulator",id:"applying-the-accumulator",level:2},{value:"World state",id:"world-state",level:3},{value:"Account storage state",id:"account-storage-state",level:3},{value:"Generating state-root-transition witnesses",id:"generating-state-root-transition-witnesses",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:'The state manager is the part of the execution client responsible for updating the state of the\nnetwork globally, and the state of every account individually. The state manager also audits the\n"read" access made in the EVM, meaning it monitors, verifies, and logs all operations where the\nEVM needs to read data from the blockchain state.'}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsx)(t.p,{children:'"State" refers to the data stored on the blockchain at any given point in time. To\nupdate state is to update the record of the contents of every account whose contents have\nchanged.'})}),"\n",(0,s.jsxs)(t.p,{children:["The main task of the state manager is to receive blocks that have been executed by the ",(0,s.jsx)(t.a,{href:"/web3-feedback/technology/sequencer/",children:"sequencer"}),"\nand use the trace data from their execution to update the state of the network. Linea uses two\ndata structure types to manage state:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["A Merkle-Patricia Trie to record the world state, maintain consensus, and process blocks. This\nmirrors how consensus and state are ",(0,s.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/",children:"managed on Ethereum Mainnet"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"A variant of regular Merkle trees called a sparse Merkle tree (SMT), which is used to more\nefficiently track, manage, and update storage slots representing accounts."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["It then passes this updated network state information to the ",(0,s.jsx)(t.a,{href:"/web3-feedback/technology/prover/",children:"prover"}),"\nin the form of Merkle proofs for submission to Ethereum Mainnet (L1)."]}),"\n",(0,s.jsx)(t.p,{children:"Below, we'll explain the element of Linea's state management in greater detail, focussing on the\nSMT configuration that sets Linea apart."}),"\n",(0,s.jsx)(t.h2,{id:"merkle-trees",children:"Merkle trees"}),"\n",(0,s.jsx)(t.p,{children:"The Merkle tree and its variations are commonly used across EVM chains to store and retrieve\ndata about the state of every account on the blockchain."}),"\n",(0,s.jsx)(t.p,{children:"A Merkle tree is comprised of 'nodes' that branch off from each other. At the base is the 'root',\nor state root, from which branches stem, and leaves stem from the branches."}),"\n",(0,s.jsx)("div",{class:"img-large",children:(0,s.jsx)("div",{class:"mermaid-medium",children:(0,s.jsx)(t.mermaid,{value:"    flowchart TD\n        A[root] --\x3e B[node] & C[node]\n        B --\x3e D[node] & E[node]\n        C --\x3e F[node] & G[node]"})})}),"\n",(0,s.jsx)(t.p,{children:"Each node, regardless of type, is represented by a cryptographic hash which encodes data about its\nproperties \u2014 for example, the contents of your account. Each hash encodes the hashes of its child\nnodes. Taken to its full extent, this cascading system means the root encodes data of the state of\nevery single account on the blockchain."}),"\n",(0,s.jsx)(t.p,{children:"Cryptographic hashes are deterministic, which means you can reverse the hash function to get the\ndata which it encoded. If you have the hash of the root\u2014the only node without a parent\u2014you can\ntheoretically derive from it the data of any node in the entire tree."}),"\n",(0,s.jsx)(t.p,{children:"As a layer 2 (L2) network, Linea is in the business of making transacting faster and more efficient.\nLinea implements a sparse Merkle tree to track account state and generate and store proofs, and\nunlock greater efficiency when compared to standard Merkle trees, which require recomputation for\nevery block, leading to excessive computational demands."}),"\n",(0,s.jsx)(t.h3,{id:"sparse-merkle-trees",children:"Sparse Merkle trees"}),"\n",(0,s.jsx)(t.p,{children:"Linea's state management uses sparse Merkle trees to minimize computation and contribute to the\nblockchain's efficiency."}),"\n",(0,s.jsx)(t.p,{children:"A sparse Merkle tree is a variation of a standard Merkle tree where not all leaf nodes are filled\nwith data; instead, data is only stored in nodes where it's needed. It is a complete tree of fixed\ndepth, meaning that all branches of the tree have the same length\u2014i.e. the same number of leaves."}),"\n",(0,s.jsxs)(t.p,{children:["At initialization\u2014the beginning of the chain's history\u2014all leaf nodes are set to a default value,\nwhich is typically a hash of a specific value, such as zero. Because all leaf nodes have the same\nhash value, the parent nodes and higher-level nodes also have the same hash value. A node whose\nhash is the default value for its level is therefore considered to represent an ",(0,s.jsx)(t.em,{children:"empty"})," subtree."]}),"\n",(0,s.jsx)("div",{class:"center-container",children:(0,s.jsx)("div",{class:"mermaid-medium",children:(0,s.jsx)(t.mermaid,{value:'flowchart TD\n    A[root] --\x3e B["`**node A**`"\n    null] & C["`**node B**`"\n    contains data]\n    B --\x3e D["`**node C**`":\n    null] & E["`**node D:**`"\n    null]\n    C --\x3e F["`**node E**`":\n    data] & G["`**node F**`":\n    data]'})})}),"\n",(0,s.jsx)(t.p,{children:"In the example above, the children of node A (leaves) contain null values, which means node A does\ntoo. Node B, meanwhile, reflects that its children also contain values."}),"\n",(0,s.jsxs)(t.p,{children:["With this construction, we do not need to keep track of every individual node's hash. Instead, we\ncan assume hashes that reflect the default value are empty, and the subtree or node that lies\nfurther down the chain of nodes can be disregarded; we only need to pay attention to the ones that\ncorrespond to ",(0,s.jsx)(t.em,{children:"non-empty"})," subtrees."]}),"\n",(0,s.jsx)(t.h2,{id:"cryptographic-accumulator",children:"Cryptographic accumulator"}),"\n",(0,s.jsx)(t.p,{children:'In this context, we can consider Linea\'s sparse Merkle tree as a type of "cryptographic\naccumulator". A cryptographic accumulator is a type of cryptographic primitive encoding a collection\nof items into very short strings and allowing read/write operations to be proven. Merkle trees and\nsparse Merkle trees are elementary examples of accumulators but there are others with more powerful\ncapabilities.'}),"\n",(0,s.jsx)(t.p,{children:"Linea's state manager uses an extended version of a sparse Merkle tree that enables it to prove all\nCRUD (create, read, update, delete) operations for a key-addressed database. As an outline, the\nconstruction uses a sparse Merkle tree to store the nodes of a sorted doubly-linked list that\nencodes all the non-zero items of the state."}),"\n",(0,s.jsx)(t.p,{children:"Linea's state manager uses the accumulator to track the account trie of Linea but also the storage\nof every contract separately."}),"\n",(0,s.jsxs)(t.p,{children:["The leaves of the tree have the following structure: ",(0,s.jsx)(t.code,{children:"prev || next || hKey || hVal"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"hKey"})," and ",(0,s.jsx)(t.code,{children:"hVal"})," are the hashes of the key and the value of the stored state entry, respectively.\n",(0,s.jsx)(t.code,{children:"prev"})," and ",(0,s.jsx)(t.code,{children:"next"})," are pointers storing the position of the leaves whose ",(0,s.jsx)(t.code,{children:"hKeys"})," are immediately\nlower and higher, respectively, following lexicographic order. The first two leaves of the SMT are\ncalled the head and the tail, and are special in that they do not encode a stored tuple. The head is\nthe lowest possible ",(0,s.jsx)(t.code,{children:"hKey"}),", while the tail is the highest possible ",(0,s.jsx)(t.code,{children:"hKey"}),". They are therefore\nsituated at the beginning and the end of the linked list, respectively. Starting from the head, we\ncan access the SMT leaf stored at ",(0,s.jsx)(t.code,{children:"head.next"}),' to get the lowest "actually stored" item. Further\nincrementing the ',(0,s.jsx)(t.code,{children:"next"})," value will give us the second-lowest stored item and so on. Repeating the\nprocess walks us through the entire set of stored items before we end up at the tail node, marking\nthe final step."]}),"\n",(0,s.jsx)(t.p,{children:"Leaves can also be referred to as storage slots, in that they contain data about the contents of\nthe account in question."}),"\n",(0,s.jsx)(t.h3,{id:"tracking-empty-leaves",children:"Tracking empty leaves"}),"\n",(0,s.jsx)(t.p,{children:"All leaves in the tree are populated with default/zero values at initialization. Since a\ndeterministic hashing function will ensure that these leaves are always represented by the same\nhash, empty leaves can be easily recognized by the accumulator."}),"\n",(0,s.jsx)(t.p,{children:"However, in order for the state manager to update a storage slot with data about a Linea account's\ncontents, it must know which empty leaf to overwrite, and exactly where these empty leaves are. A\nfurther consideration is that we require the index of any 'new' leaf\u2014an empty leaf being updated\nso that it stores data\u2014to be overwritten in a deterministic way. This requirement means that anyone\ncan theoretically reconstruct the tree simply by looking at transaction history."}),"\n",(0,s.jsx)(t.p,{children:"To ensure consistency in the leaves' position, the state manager only ever inserts 'new' leaves to\nthe left of the previous leaf in the tree. If this wasn't the case, and the state manager was able\nto insert any node in any position, it would be impossible to reconstitute the tree in the exact\nsame configuration, severely impacting the ability of L1 to verify the Merkle proof provided."}),"\n",(0,s.jsx)(t.h2,{id:"applying-the-accumulator",children:"Applying the accumulator"}),"\n",(0,s.jsxs)(t.p,{children:["The Ethereum Virtual Machine (EVM) uses a variant of a Merkle tree known as a ",(0,s.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/",children:"Merkle-Patricia Trie"})," to track:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"World state, which keeps track of accounts, and;"}),"\n",(0,s.jsx)(t.li,{children:"Account storage state (or simply 'storage'), which keeps track of the contents of each account."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"On Linea, we adapt this structure. The Merkle-Patricia Trie is still used for world state, but the\ncustom cryptographic accumulator described above is used for account storage state."}),"\n",(0,s.jsx)(t.p,{children:"The accumulator can perform the following operations:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Insertion"}),": adding a new storage slot to the tree, triggered by storing a non-zero value in a\npreviously zero-valued slot."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Update"}),": changing the value of an existing storage slot in the tree, triggered by storing a new\nnon-zero value in a previously non-zero slot."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Deletion"}),": removing a storage slot from the tree, triggered by storing the zero value in a\npreviously non-zero slot."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Read zero"}),": proving non-membership, triggered when a storage slot has been accessed, but not\nupdated, and its value is zero."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Read non-zero"}),": proving membership, triggered when a storage slot has been accessed, but not\nupdated and its value is non-zero."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["These operations are applied to two trees; ",(0,s.jsx)(t.a,{href:"#world-state",children:"world state"})," and ",(0,s.jsx)(t.a,{href:"#account-storage-state",children:"account storage state"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"world-state",children:"World state"}),"\n",(0,s.jsxs)(t.p,{children:["The world state tree maps all accounts that exist on the blockchain\u2014contracts and externally-owned\naccounts (EOAs)\u2014and points towards the account storage state for each. While on Ethereum Mainnet,\nthis data is stored in a standard trie, Linea uses the accumulator to map accounts as key",":value","\npairs. Otherwise, the implementation is similar to the EVM."]}),"\n",(0,s.jsx)(t.p,{children:"Their structure is as follows:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"HKey"}),": Hash(",(0,s.jsx)(t.code,{children:"address"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Val"}),": Hash(",(0,s.jsx)(t.code,{children:"nonce"}),", ",(0,s.jsx)(t.code,{children:"balance"}),", ",(0,s.jsx)(t.code,{children:"storageRoot"}),", ",(0,s.jsx)(t.code,{children:"codeHash"}),", ",(0,s.jsx)(t.code,{children:"keccakCodeHash"}),", ",(0,s.jsx)(t.code,{children:"CodeSize"}),")"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Critically, every piece of data fed into the ",(0,s.jsx)(t.code,{children:"Val"})," (value) hash function must have a finite field\ninterpretation. The data must be formatted this way to enable the Linea prover to correctly\naccess the world state when verifying proofs. Each element is formatted as follows (all elements\nrequire one field, other than ",(0,s.jsx)(t.code,{children:"keccakCodeHash"}),"):"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"nonce"}),": The nonce is written in big-endian form into a ",(0,s.jsx)(t.code,{children:"byte32"}),". For instance if the nonce is 10,\nthen the nonce should be encoded as ",(0,s.jsx)(t.code,{children:"0x000000000000000000000000000000000000000000000000000000000000000a"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"balance"}),": Formatted the same as the nonce; big-endian ",(0,s.jsx)(t.code,{children:"byte32"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"storageRoot"}),": The storage root should ",(0,s.jsx)(t.em,{children:"not"})," be the Keccak of the Patricia trie root as in the\nEVM, but the \u201ccustom Merkle tree\u201d root of the account storage state that we describe in the\n",(0,s.jsx)(t.a,{href:"#account-storage-state",children:"following section"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"codeHash"}),": The code hash should not be the Keccak of the code, it should instead be the one\nobtained as described in the following section."]}),"\n",(0,s.jsxs)(t.li,{children:["2 field elements for ",(0,s.jsx)(t.code,{children:"keccakCodeHash"}),": One for the 128 most significant bits and one for the 128\nleast significant bits. The Keccak code hash corresponds exactly to the Keccak hash as specified by\nthe EVM (i.e. the output of ",(0,s.jsx)(t.a,{href:"https://eips.ethereum.org/EIPS/eip-1052",children:"EXTCODEHASH"}),". We keep the\nKeccak and the \u201ccustom\u201d version for practical reasons."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"codeSize"}),": The code size should be the same value as that returned by the CODESIZE/EXTCODESIZE\nopcodes."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"account-storage-state",children:"Account storage state"}),"\n",(0,s.jsxs)(t.p,{children:["Also referred to as the storage trie, the account storage state is the database the state manager\naccesses to retrieve data about the contents of accounts. Account storage is mainly relevant for\ncontract accounts; for EOAs, the data about assets and transactions is stored in the ",(0,s.jsx)(t.a,{href:"#world-state",children:"world state"}),"\n",(0,s.jsx)(t.code,{children:"Val"}),", and the ",(0,s.jsx)(t.code,{children:"codeHash"})," and its variants are empty."]}),"\n",(0,s.jsx)(t.p,{children:"Since the main function of account storage is to record contracts in such a way that they can be\neasily retrieved and processed, it must efficiently encode the contract. It does this using the\nfollowing format:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"HKey"}),": Hash(",(0,s.jsx)(t.code,{children:"StorageKeyMSB"}),", ",(0,s.jsx)(t.code,{children:"StorageKeyLSB"}),")"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Val"}),": Hash(",(0,s.jsx)(t.code,{children:"StorageValueMSB"}),", ",(0,s.jsx)(t.code,{children:"StorageValueLSB"}),")"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["In both cases, the ",(0,s.jsx)(t.code,{children:"MSB"})," refers to the first 16 bytes of a 'word', and ",(0,s.jsx)(t.code,{children:"LSB"})," the last 16. 'Word' in\nthis context refers to the natural unit of data used by the EVM, which is 256-bit (32 byte) chunks."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, if the data regarding a contract's code was encoded in a ",(0,s.jsx)(t.code,{children:"byte32"}),", the standard data\ntype for words on the EVM and equivalents like Linea, it might look like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"[a0, a1, a2, \u2026., a15, b0, b1, \u2026, b15]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["That ",(0,s.jsx)(t.code,{children:"byte32"})," would be split into an ",(0,s.jsx)(t.code,{children:"MSB"})," and ",(0,s.jsx)(t.code,{children:"LSB"})," like this:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"MSB"}),": ",(0,s.jsx)(t.code,{children:"[0, 0, .., 0, a0, a1, a2, a3, .., a15]"})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"LSB"}),": ",(0,s.jsx)(t.code,{children:"[0, 0, .., 0, b0, b1, b2, b3, .., b15]"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"MSB"})," takes the first 16 bytes, and the ",(0,s.jsx)(t.code,{children:"LSB"})," the second 16 bytes."]}),"\n",(0,s.jsx)(t.h2,{id:"generating-state-root-transition-witnesses",children:"Generating state-root-transition witnesses"}),"\n",(0,s.jsx)(t.p,{children:"The accumulator, built using a sparse Merkle tree, is simultaneously:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"A data structure on which we can perform operations;"}),"\n",(0,s.jsx)(t.li,{children:"A dataset that we can summarize using a short string at any time (i.e. the root hash);"}),"\n",(0,s.jsx)(t.li,{children:"A tool that can be used by the Linea protocol to verify that a given operation triggered a\ntransition from hash A to hash B."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'Once the accumulator has processed the trace information it receives about a new block and updated\nstate accordingly, it can pass a new state root hash to the prover, via the coordinator. The state\nroot hash can then be used by the prover as a "witness": a verifiable method of proving that the\ntransactions in each block have taken place, without having to divulge the nature of those\ntransactions.'})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);