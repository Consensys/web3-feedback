"use strict";(self.webpackChunkweb3_feedback=self.webpackChunkweb3_feedback||[]).push([[6783],{28453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>s});var t=n(96540);const a={},r=t.createContext(a);function o(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(r.Provider,{value:i},e.children)}},80242:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"zero-knowledge-glossary/index","title":"Zero knowledge glossary","description":"An open source glossary to aid your zero knowledge journey!","source":"@site/docs/zero-knowledge-glossary/index.mdx","sourceDirName":"zero-knowledge-glossary","slug":"/zero-knowledge-glossary/","permalink":"/web3-feedback/zero-knowledge-glossary/","draft":false,"unlisted":false,"editUrl":"https://github.com/Consensys/doc.linea/tree/main/docs/zero-knowledge-glossary/index.mdx","tags":[],"version":"current","lastUpdatedBy":"Joel Willmore","lastUpdatedAt":1746010655000,"sidebarPosition":7,"frontMatter":{"title":"Zero knowledge glossary","description":"An open source glossary to aid your zero knowledge journey!","sidebar_position":7,"image":"/img/socialCards/zero-knowledge-glossary.jpg"}}');var a=n(74848),r=n(28453);const o={title:"Zero knowledge glossary",description:"An open source glossary to aid your zero knowledge journey!",sidebar_position:7,image:"/img/socialCards/zero-knowledge-glossary.jpg"},s=void 0,l={},c=[{value:"A",id:"a",level:2},{value:"arithmetization",id:"arithmetization",level:3},{value:"appchain",id:"appchain",level:3},{value:"B",id:"b",level:2},{value:"blockchain trilemma",id:"blockchain-trilemma",level:3},{value:"Brakedown",id:"brakedown",level:3},{value:"C",id:"c",level:2},{value:"circuit",id:"circuit",level:3},{value:"constraint",id:"constraint",level:3},{value:"D",id:"d",level:2},{value:"data availability",id:"data-availability",level:3},{value:"E",id:"e",level:2},{value:"elliptic curve cryptography",id:"elliptic-curve-cryptography",level:3},{value:"Ethereum Virtual Machine (EVM)",id:"ethereum-virtual-machine-evm",level:3},{value:"execution trace",id:"execution-trace",level:3},{value:"F",id:"f",level:2},{value:"Fraud proof",id:"fraud-proof",level:3},{value:"G",id:"g",level:2},{value:"gnark",id:"gnark",level:3},{value:"Groth16",id:"groth16",level:3},{value:"H",id:"h",level:2},{value:"hash function",id:"hash-function",level:3},{value:"I",id:"i",level:2},{value:"J",id:"j",level:2},{value:"K",id:"k",level:2},{value:"keccak",id:"keccak",level:3},{value:"L",id:"l",level:2},{value:"Layer 1",id:"layer-1",level:3},{value:"Layer 2",id:"layer-2",level:3},{value:"M",id:"m",level:2},{value:"N",id:"n",level:2},{value:"O",id:"o",level:2},{value:"Oracle",id:"oracle",level:3},{value:"Optimistic rollup",id:"optimistic-rollup",level:3},{value:"P",id:"p",level:2},{value:"Polynomial commitment",id:"polynomial-commitment",level:3},{value:"Polynomial IOP (Interactive Oracle Proof)",id:"polynomial-iop-interactive-oracle-proof",level:3},{value:"Q",id:"q",level:2},{value:"R",id:"r",level:2},{value:"Rollup",id:"rollup",level:3},{value:"S",id:"s",level:2},{value:"Scaling",id:"scaling",level:3},{value:"Sidechain",id:"sidechain",level:3},{value:"T",id:"t",level:2},{value:"Transaction fee",id:"transaction-fee",level:3},{value:"U",id:"u",level:2},{value:"V",id:"v",level:2},{value:"Validity proof",id:"validity-proof",level:3},{value:"Verifiable computation",id:"verifiable-computation",level:3},{value:"W",id:"w",level:2},{value:"X",id:"x",level:2},{value:"Y",id:"y",level:2},{value:"Z",id:"z",level:2},{value:"Zero-knowledge proof",id:"zero-knowledge-proof",level:3},{value:"Zero-knowledge rollup",id:"zero-knowledge-rollup",level:3},{value:"zkEVM",id:"zkevm",level:3},{value:"zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge)",id:"zk-snark-zero-knowledge-succinct-non-interactive-argument-of-knowledge",level:3}];function h(e){const i={a:"a",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(i.p,{children:["This glossary is open source and consistently being updated. If you'd like a term to be added, please ",(0,a.jsx)(i.a,{href:"https://github.com/Consensys/doc.linea/issues",children:"create an issue"})," or create a pull request and define one yourself!"]}),"\n",(0,a.jsx)(i.h2,{id:"a",children:"A"}),"\n",(0,a.jsx)(i.h3,{id:"arithmetization",children:"arithmetization"}),"\n",(0,a.jsx)(i.p,{children:'Arithmetization is the process of turning computational problems into equations. It can be summarized as turning computer programs into "math," so that they can be analyzed using cryptographic algebraic techniques.'}),"\n",(0,a.jsx)(i.h3,{id:"appchain",children:"appchain"}),"\n",(0,a.jsx)(i.p,{children:"A blockchain network custom-made and optimized for a specific application's needs. An appchain is generally not a full-blown blockchain, but offers an optimized execution environment for the application, while still relying on an underlying blockchain for consensus."}),"\n",(0,a.jsx)(i.p,{children:"Deploying appchains on top of L2 networks like Linea offers significant cost and customization capabilities."}),"\n",(0,a.jsx)(i.p,{children:'See also: "blockchain trilemma", "modular blockchain", "Layer 2", "Layer 3".'}),"\n",(0,a.jsx)(i.h2,{id:"b",children:"B"}),"\n",(0,a.jsx)(i.h3,{id:"blockchain-trilemma",children:"blockchain trilemma"}),"\n",(0,a.jsx)(i.p,{children:"Blockchain network builders face a tradeoff between three factors: decentralization, security, and scalability (or speed). Often, designing a system that optimizes for one compromises another."}),"\n",(0,a.jsx)(i.h3,{id:"brakedown",children:"Brakedown"}),"\n",(0,a.jsx)(i.p,{children:"The first built system that provides linear-time SNARKs for NP, meaning the prover incurs O(N) finite field operations to prove the satisfiability of an N-sized R1CS instance. Brakedown\u2019s prover is faster, both concretely and asymptotically, than prior SNARK implementations."}),"\n",(0,a.jsx)(i.p,{children:"Brakedown doesn't require a trusted setup and is plausibly post-quantum secure."}),"\n",(0,a.jsx)(i.h2,{id:"c",children:"C"}),"\n",(0,a.jsx)(i.h3,{id:"circuit",children:"circuit"}),"\n",(0,a.jsx)(i.p,{children:"A circuit uses logic gates to depict the flow of data and the sequence of operations performed on that data in a given computational task. Circuits are used at many levels to create processing capability, including virtual machines like the Ethereum Virtual Machine, and Linea's implementation of a zkEVM."}),"\n",(0,a.jsx)(i.h3,{id:"constraint",children:"constraint"}),"\n",(0,a.jsx)(i.p,{children:"A constraint refers to a condition imposed on mathematical operations or computation to ensure the correctness, efficiency, or security of an algorithm."}),"\n",(0,a.jsx)(i.h2,{id:"d",children:"D"}),"\n",(0,a.jsx)(i.h3,{id:"data-availability",children:"data availability"}),"\n",(0,a.jsx)(i.p,{children:"Data availability is the guarantee that the block proposers are required to publish the data for each block, which nodes participating in Ethereum's consensus store locally. Rather than having to trust that block producers are honest, all nodes on the Ethereum network execute the transactions to verify that the new information is valid."}),"\n",(0,a.jsxs)(i.p,{children:["Data availability is one of the ways in which a ",(0,a.jsx)(i.a,{href:"#layer-2",children:"L2"})," differs from a ",(0,a.jsx)(i.a,{href:"#sidechain",children:"sidechain"}),"."]}),"\n",(0,a.jsx)(i.h2,{id:"e",children:"E"}),"\n",(0,a.jsx)(i.h3,{id:"elliptic-curve-cryptography",children:"elliptic curve cryptography"}),"\n",(0,a.jsx)(i.p,{children:'A method of encrypting information used in many applications, including in public blockchain networks. It is commonly used to create "public-private key pairs": a pair of cryptographic elements. The public key can be used to encrypt things which can then only be decrypted by the private key.'}),"\n",(0,a.jsx)(i.p,{children:"ECC uses mathematical theories surrounding elliptic curves to render the encryption extremely difficult to decipher without the correct private key."}),"\n",(0,a.jsx)(i.h3,{id:"ethereum-virtual-machine-evm",children:"Ethereum Virtual Machine (EVM)"}),"\n",(0,a.jsx)(i.p,{children:"A stack-based virtual machine that executes bytecode. In Ethereum, the execution model specifies how the system state is altered given a series of bytecode instructions and a small tuple of environmental data. This is specified through a formal model of a virtual state machine."}),"\n",(0,a.jsx)(i.h3,{id:"execution-trace",children:"execution trace"}),"\n",(0,a.jsx)(i.p,{children:"This is a record of what happened during the execution of a transaction. This is usually represented as a list, in which each item is the state of the machine at a specific clock time, which includes information such as:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Who was the caller"}),"\n",(0,a.jsx)(i.li,{children:"Block number"}),"\n",(0,a.jsx)(i.li,{children:"What contracts were invoked"}),"\n",(0,a.jsx)(i.li,{children:"What data was changed"}),"\n",(0,a.jsx)(i.li,{children:"And more!"}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:["This is relevant to zk-rollups because execution traces are used to construct the ",(0,a.jsx)(i.a,{href:"#validity-proof",children:"validity proof"})," verified by the verifier contract on Ethereum."]}),"\n",(0,a.jsx)(i.h2,{id:"f",children:"F"}),"\n",(0,a.jsx)(i.h3,{id:"fraud-proof",children:"Fraud proof"}),"\n",(0,a.jsx)(i.p,{children:"In optimistic rollups, fraud proofs (fault proofs) are the evidence a verifier provides to question the validity of a batch of transactions. Depending on how they are executed, these proofs scrutinize a section of transactions and endeavor to confirm their validity."}),"\n",(0,a.jsx)(i.h2,{id:"g",children:"G"}),"\n",(0,a.jsx)(i.h3,{id:"gnark",children:"gnark"}),"\n",(0,a.jsx)(i.p,{children:"gnark is a software library that offers users the ability to design and run computational circuits in zk-SNARKs through a high-level API."}),"\n",(0,a.jsx)(i.p,{children:"The library is open source and developed under the Apache 2.0 license."}),"\n",(0,a.jsx)(i.h3,{id:"groth16",children:"Groth16"}),"\n",(0,a.jsx)(i.p,{children:"Groth16 is a circuit-specific preprocessing general-purpose zk-SNARK construction. It has become a de-facto standard used in several blockchain projects due to the constant size of its proof, and its appealing verifier time."}),"\n",(0,a.jsx)(i.p,{children:"On the downside, Groth16 needs a circuit-specific trusted setup for its preprocessing phase."}),"\n",(0,a.jsx)(i.h2,{id:"h",children:"H"}),"\n",(0,a.jsx)(i.h3,{id:"hash-function",children:"hash function"}),"\n",(0,a.jsx)(i.p,{children:"A mathematical function that converts a data input of any chosen length and size into an output that is encrypted and has a fixed length and size. Once converted, the hash cannot be reverse-engineered to reveal the original input of data. This makes the data input more secure against decryption."}),"\n",(0,a.jsx)(i.h2,{id:"i",children:"I"}),"\n",(0,a.jsx)(i.h2,{id:"j",children:"J"}),"\n",(0,a.jsx)(i.h2,{id:"k",children:"K"}),"\n",(0,a.jsx)(i.h3,{id:"keccak",children:"keccak"}),"\n",(0,a.jsx)(i.p,{children:"Keccak (pronounced \u201cketchak\u201d) is a versatile cryptographic function best known for its uses in hashing. It provides increased levels of security when compared to older hash algorithms."}),"\n",(0,a.jsx)(i.p,{children:"See also: SHA, hash function."}),"\n",(0,a.jsx)(i.h2,{id:"l",children:"L"}),"\n",(0,a.jsx)(i.h3,{id:"layer-1",children:"Layer 1"}),"\n",(0,a.jsx)(i.p,{children:"Layer 1 (L1) is the underlying foundation and base blockchain that various layer 2 (L2) networks build on top of. For example, Ethereum is an L1 that is comprised of node operators to secure and validate the network, block producers, the history of transaction data, and the consensus mechanism of the blockchain itself."}),"\n",(0,a.jsx)(i.h3,{id:"layer-2",children:"Layer 2"}),"\n",(0,a.jsx)(i.p,{children:"Layer 2 (L2) is a separate blockchain that increases transaction speed and throughput, while fully or partially deriving its security from Ethereum. Additionally, L2 projects must rely on Ethereum for data availability by posting their transaction data onto Ethereum. L2s decrease L1 congestion by bundling transactions to be submitted to Ethereum, thus increasing scalability while inheriting Ethereum\u2019s data availability, security, and decentralization."}),"\n",(0,a.jsx)(i.h2,{id:"m",children:"M"}),"\n",(0,a.jsx)(i.h2,{id:"n",children:"N"}),"\n",(0,a.jsx)(i.h2,{id:"o",children:"O"}),"\n",(0,a.jsx)(i.h3,{id:"oracle",children:"Oracle"}),"\n",(0,a.jsx)(i.p,{children:"This is a computational entity or service that provides information or answers to specific queries."}),"\n",(0,a.jsx)(i.h3,{id:"optimistic-rollup",children:"Optimistic rollup"}),"\n",(0,a.jsxs)(i.p,{children:["A rollup of transactions that use ",(0,a.jsx)(i.a,{href:"#fraud-proof",children:"fraud proofs"})," to offer increased ",(0,a.jsx)(i.a,{href:"#layer-2",children:"L2"})," transaction throughput while using the security provided by Mainnet (",(0,a.jsx)(i.a,{href:"#layer-1",children:"L1"}),"). Unlike Plasma, a similar ",(0,a.jsx)(i.a,{href:"#layer-2",children:"L2"})," solution, optimistic rollups can handle more complex transaction types \u2013 anything possible in the EVM. However, in order to release assets back on the L1, users must wait for a seven-day challenge period. Liquidity providers can help alleviate distributing L1 ETH immediately, but this relies on trust in the security of the provider, and doesn't provide a mechanism for transferring NFTs."]}),"\n",(0,a.jsx)(i.h2,{id:"p",children:"P"}),"\n",(0,a.jsx)(i.h3,{id:"polynomial-commitment",children:"Polynomial commitment"}),"\n",(0,a.jsx)(i.p,{children:"A polynomial commitment scheme is a cryptographic primitive that allows a party to publicly commit to a value or a piece of information without ever revealing the actual value itself. This allows us to prove that a polynomial satisfies some properties without ever revealing what the polynomial is. Additionally, this is useful for zk-rollups because the commitment is smaller than the polynomial itself."}),"\n",(0,a.jsx)(i.h3,{id:"polynomial-iop-interactive-oracle-proof",children:"Polynomial IOP (Interactive Oracle Proof)"}),"\n",(0,a.jsxs)(i.p,{children:["An Interactive Oracle Proof (IOP) is a protocol in which the verifier is not required to fully read the prover's messages (the ",(0,a.jsx)(i.a,{href:"#execution-trace",children:"traces"})," and ",(0,a.jsx)(i.a,{href:"#constraint",children:"constraints"})," generated from ",(0,a.jsx)(i.a,{href:"#arithmetization",children:"arithmetization"}),"). Instead, the verifier has ",(0,a.jsx)(i.a,{href:"#oracle",children:"oracle"})," access to the prover\u2019s messages. This oracle is repeatedly queried to create the concrete proof system, or ",(0,a.jsx)(i.a,{href:"#polynomial-commitment",children:"polynomial commitment"})," for the ",(0,a.jsx)(i.a,{href:"#validity-proof",children:"validity proof"}),"."]}),"\n",(0,a.jsx)(i.h2,{id:"q",children:"Q"}),"\n",(0,a.jsx)(i.h2,{id:"r",children:"R"}),"\n",(0,a.jsx)(i.h3,{id:"rollup",children:"Rollup"}),"\n",(0,a.jsxs)(i.p,{children:["A type of ",(0,a.jsx)(i.a,{href:"#layer-2",children:"L2"})," scaling solution that batches multiple transactions and submits them to the Ethereum main chain in a single transaction. This allows for reductions in gas costs and increases in transaction throughput. There are optimistic and zero-knowledge rollups, which use different security methods to offer these scalability gains."]}),"\n",(0,a.jsx)(i.p,{children:"Rollup architecture is made up of the following components:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Rollup contract"}),": contract on the L1 stores rollup blocks, monitors state updates on the rollup, and tracks user deposits"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Off-chain VM"}),": computation and state storage on another virtual machine separate from the Ethereum Virtual Machine"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Aggregators/sequencers/operators/validators"}),": nodes that aggregate transactions, compress the underlying data, and publish the block on Ethereum"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Verifier contract"}),": contract on the L1 that verifies the ",(0,a.jsx)(i.a,{href:"#validity-proof",children:"validity proof"})]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"s",children:"S"}),"\n",(0,a.jsx)(i.h3,{id:"scaling",children:"Scaling"}),"\n",(0,a.jsx)(i.p,{children:"The main goal of scalability is to increase transaction speed (faster finality), and transaction throughput (high transactions per second), without sacrificing decentralization or security."}),"\n",(0,a.jsx)(i.h3,{id:"sidechain",children:"Sidechain"}),"\n",(0,a.jsxs)(i.p,{children:["A scaling solution that uses a separate chain with different, often faster, consensus rules. A bridge is needed to connect these sidechains to Mainnet. Rollups also use sidechains, but they operate in collaboration with Mainnet instead. Sidechains are NOT considered ",(0,a.jsx)(i.a,{href:"#layer-2",children:"L2"})," solutions, because they do not leverage Ethereum for data availability and security."]}),"\n",(0,a.jsx)(i.h2,{id:"t",children:"T"}),"\n",(0,a.jsx)(i.h3,{id:"transaction-fee",children:"Transaction fee"}),"\n",(0,a.jsx)(i.p,{children:"A fee you need to pay whenever you use the Ethereum network. Examples include: sending funds from your wallet, or a dapp interaction, like swapping tokens or buying a collectible. You can think of this like a service charge. This fee will change based on how busy the network is. This is because miners or sequencers, the people responsible for processing your transaction depending on the network, are likely to prioritize transactions with higher fees \u2013 so congestion forces the price up."}),"\n",(0,a.jsx)(i.h2,{id:"u",children:"U"}),"\n",(0,a.jsx)(i.h2,{id:"v",children:"V"}),"\n",(0,a.jsx)(i.h3,{id:"validity-proof",children:"Validity proof"}),"\n",(0,a.jsxs)(i.p,{children:["A security model for certain ",(0,a.jsx)(i.a,{href:"#layer-2",children:"L2"})," solutions where, to increase speed, transactions are rolled up into batches and submitted to Ethereum in a single transaction. The transaction computation is done off-chain and then supplied to the main chain with a proof of their validity. This method increases the amount of transactions possible while maintaining security. Some rollups use ",(0,a.jsx)(i.a,{href:"#fraud-proof",children:"fraud proofs"}),"."]}),"\n",(0,a.jsx)(i.h3,{id:"verifiable-computation",children:"Verifiable computation"}),"\n",(0,a.jsx)(i.p,{children:"Verifiable computation allows a \u201cweak computer\u201d (Ethereum L1) to offload computation to a potentially untrusted, but \u201cpowerful computer\u201d (Linea L2). The \u201cpowerful computer\u201d must return a validity proof of the correctness of its results. Verifying the proof is cheaper than performing the computation from scratch."}),"\n",(0,a.jsx)(i.h2,{id:"w",children:"W"}),"\n",(0,a.jsx)(i.h2,{id:"x",children:"X"}),"\n",(0,a.jsx)(i.h2,{id:"y",children:"Y"}),"\n",(0,a.jsx)(i.h2,{id:"z",children:"Z"}),"\n",(0,a.jsx)(i.h3,{id:"zero-knowledge-proof",children:"Zero-knowledge proof"}),"\n",(0,a.jsxs)(i.p,{children:["A zero-knowledge proof, or zk-proof, is a cryptographic method that allows an individual to prove that a statement is true without conveying any additional information. This is commonly associated with privacy, but is great for ",(0,a.jsx)(i.em,{children:"scaling"})," blockchain networks through rollups, because it reduces the amount of information you have to provide to lower layers. This is the ",(0,a.jsx)(i.a,{href:"#validity-proof",children:"validity proof"})," that the \u201cpowerful computer\u201d must provide for ",(0,a.jsx)(i.a,{href:"#verifiable-computation",children:"verifiable computation"}),"."]}),"\n",(0,a.jsx)(i.h3,{id:"zero-knowledge-rollup",children:"Zero-knowledge rollup"}),"\n",(0,a.jsxs)(i.p,{children:["This is a ",(0,a.jsx)(i.a,{href:"#layer-2",children:"L2 scaling solution"})," that uses a ",(0,a.jsx)(i.a,{href:"#zero-knowledge-proof",children:"zero-knowledge proof"})," as its ",(0,a.jsx)(i.a,{href:"#validity-proof",children:"validity proof"})," to post data back to Ethereum L1. As compared to ",(0,a.jsx)(i.a,{href:"#optimistic-rollup",children:"optimistic rollups"}),", this validity proof allows for a more secure trust assumption and removes the need for a challenge period."]}),"\n",(0,a.jsx)(i.h3,{id:"zkevm",children:"zkEVM"}),"\n",(0,a.jsx)(i.p,{children:"A zkEVM is a virtual machine that executes smart contracts and proves the correctness of execution using zero-knowledge proofs. ZkEVMs recreate aspects of Ethereum\u2019s design, which provides an \u201cEthereum-like\u201d experience for developers and users. For Ethereum developers, this means you can write in Solidity, but leverage the zkEVM to perform off-chain computations to offload execution from Ethereum, enabling the scalability provided by zk-rollups!"}),"\n",(0,a.jsx)(i.h3,{id:"zk-snark-zero-knowledge-succinct-non-interactive-argument-of-knowledge",children:"zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge)"}),"\n",(0,a.jsxs)(i.p,{children:["This is a type of zk-proof where the prover and verifier don\u2019t have to interact. With zk-SNARKs, you can verify 1 transaction or 1 billion transactions in the same amount of time, which is great for scaling. You can read more about zk-SNARKs ",(0,a.jsx)(i.a,{href:"https://consensys.net/blog/blockchain-explained/zero-knowledge-proofs-starks-vs-snarks/",children:"here"})," and ",(0,a.jsx)(i.a,{href:"https://docs.gnark.consensys.net/Concepts/zkp",children:"here"}),"."]})]})}function d(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);